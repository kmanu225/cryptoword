from Crypto.Util.number import bytes_to_long, long_to_bytes
from gmpy2 import powmod, invert
from hashlib import sha256


### Indicatrice d'Euler ou de Carmichael dans ce cas
phi_n = lambda p, q: (p - 1) * (q - 1)
inverse_modulo = lambda e, phi: invert(e, phi)

### c = m^e mod n et m = c^d mod n
encrypt = lambda m, e, n: powmod(m, e, n)
decrypt = lambda c, d, n: powmod(c, d, n)
signature = lambda msg, d, N: encrypt(bytes_to_long(sha256(msg).digest()), d, N)


if __name__ == "__main__":
    p, q = (
        134460556242811604004061671529264401215233974442536870999694816691450423689575549530215841622090861571494882591368883283016107051686642467260643894947947473532769025695530343815260424314855023688439603651834585971233941772580950216838838690315383700689885536546289584980534945897919914730948196240662991266027,
        161469718942256895682124261315253003309512855995894840701317251772156087404025170146631429756064534716206164807382734456438092732743677793224010769460318383691408352089793973150914149255603969984103815563896440419666191368964699279209687091969164697704779792586727943470780308857107052647197945528236341228473,
    )
    n = p * q
    e_list = [106979, 108533, 69557, 97117, 103231]
    d_list = [inverse_modulo(e, phi_n(p, q)) for e in e_list]
    print(f"n = {n}\nd = {d_list}")
    
    c = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
    
    for d in d_list:
        c = decrypt(c, d, n)
    print(long_to_bytes(c).decode())
    
    